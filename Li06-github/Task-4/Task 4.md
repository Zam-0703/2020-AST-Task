# Task 4

##### 首先，对Task 1未完成习题补交（对已给答案的题目就不再此处写了）

##### 下面是对Task 3未完成的提高任务的补充

对于提高任务2

#include<stdio.h>
struct Test
{
	int Num;
	char *pcName;*

​    short sDate；

​	char cha[2];
​    short sBa[4];
 }*p;
 int main()
 {
 	p=0x100000;
 	printf("%p\n",p+0x1);
 	printf("%p\n",(unsigned long)p+0x1);
 	printf("%p\n",(unsigned int*)p+0x1);

 	return 0;

}

  我并没有完全弄清楚，因此只能说一下我自己的理解。

  首先，在这个程序中，定义了一个结构指针，并且在printf中对指针的地址进行运算。

1， 在第一个printf中直接对p进行+0x1的操作，此时指针将跳过一个结构变量的整体，指向内存中下一个结构变量，此时指针对应的地址增量取决于它所指的结构变量的数据长度。但我对于指针的数据长度还不够了解，故只能通过运行的结果知道此结构对应的数据长度是32。（0000000000100020）

 2，而在第二个printf中先对p进行了强制整形，将p变为无符号长整型变量，因此，p+0x1的结果就是直接加1，即0000000000010001。

 3，在第三个printf中将p转化为int型指针，对int型指针加1，即指向下一个变量地址，由于int的数据长度是4，故地址应加4，所以结果为0000000000100004.

对于提高任务二

#include<stdio.h>
int main()
{
	int a[4]={1,2,3,4};
	int*ptr1=(int*)(&a+1);
	int*ptr2=(int*)((int)a+1);
	printf("%x\n%x\n",ptr1[-2],*ptr2);

​    return 0；

}

我想说一下我的理解：

首先定义了一个数组，接着又定义了两个int型指针。第一个指针取得是&a+1的地址，由于对数组a前使用了取地址符（感觉相当于把整个数组a看作了一个指针），故对其+1操作指向了以整个数组为单元的下一个地址。因此ptr1【-2】，即为从数组a的末尾处向前数两个元素，即为3.

再看第二个指针，先对a进行了强制整型，使其地址变为int型。因此，此时对a+1就不是指向下一个元素（+4），而是地址+1。在printf时就是从这个地址开始读取，但会出现2000000的原因，我还没有弄清楚，还要再继续学习。