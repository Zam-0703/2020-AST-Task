# 学习笔记#3

##### 1.为什么C语言数组中，构成数组的各个元素必须具有相同的数据类型？

我的看法：在内存中开辟一块连续且大小相同的空间比较容易，而开辟出连续但大小不相同的的空间则不太容易控制，且影响运行时间。C语言中各数据类型分配的储存空间都不同，故而具有相同数据类型方便操作。

##### 2.程序一

​	顺利完成。上次学了递归，还没有掌握，正好用这个题练练。

##### 3.程序二

​	看了书上的atio()函数，尝试用了一下，但是每次只要一改成这个函数就没有输出....不知道原因。

​	思路借鉴了网上程序，利用一个flag值判断是否是在一个数字之后。

​	处理字符串只用一个循环（这对我做下一题的思维产生了限制orz

##### 4.程序三

​	想了很久。因为在延续上一题一个循环的想法，在判断 '.' 的时候要想录入得在内层循环改变计数菌的值。最后逻辑太复杂咋写都不对，放弃，同时意识到不应该用一个循环。

​	后来又在网上找到大佬代码....（膜拜 看的很懂，启发也很大，各个模块分工明确，检查是否为数字、计算输出值、录入数组均分开编写。我也深刻体会到了分模块对一个清晰的逻辑的重要性，而且开始敲之前，一定要有一个好的思路！！不要朦胧之中就开始写，很浪费时间。

这几个题目做的有点抢进度，因为我只是看完了知识部分还没做书上练习就开始做题orz。

赶去巩固字符串基础，后面的几个程序示例下次再想（逃

##  提高的代码理解

##### 1.

![Snipaste_2020-11-02_18-45-42](C:\Users\23908\Desktop\Snipaste_2020-11-02_18-45-42.png)

输出：

![Snipaste_2020-11-02_18-44-39](C:\Users\23908\Desktop\Snipaste_2020-11-02_18-44-39.png)

分析：

char* c[]定义了一个一维的字符串数组，char** cp[]={}是定义了一个指针数组，数组中每个元素都是char** 的指针，其实就是char*** 类型，而最后声明的cpp其实就是cp，只不过cp是数组名不能改变，而cpp的值可以改变（即进行后面的自加操作）

第一行输出：++cpp是指cp+1, * (cp+1）是cp[1]=c+2,** (cp+1)=*(c+2)=‘POINT’

第二行输出：++cpp=cp+2; * ++cpp=* （cp+2）=c+1; --(c+1)=c; *(c+1)=“ENTER”；最后又加三即从enter的第四位开始输出至结束

第三行输出：数组里面用负数，一开始完全没看懂....后来查阅资料，得知这种操作的意义。此时cpp已经等于cp+2，所以cpp[-2]=* (cpp-2)=* (cp+2-2)=* cp (=cp[0]) =c+3,再加三同理

第四行输出：由上一行。[]不改变cpp的值，所以cpp==cp+2；先算前面一个[-1],所以cpp[-1]=* (cpp-1)=* (cp+2-1)= * (cp+1)=c+2; 再来一个[-1]得：(c+2)[-1]=* (c+2-1)=* (c+1)=“NEW”；再加三同理。



2.

![Snipaste_2020-11-02_18-58-26](C:\Users\23908\Desktop\Snipaste_2020-11-02_18-58-26.png)

输出：

![Snipaste_2020-11-02_18-57-54](C:\Users\23908\Desktop\Snipaste_2020-11-02_18-57-54.png)

分析：

首先0x100000是一个地址，而0x100000是十六进制下的0

公式：p+n 的地址值 =（p）+n*sizeof（p）

通过sizeof（Test）=32可得Test占32个字节，则第一个输出是则是（p）+1*32=0x100020

第二个就是把p强制转换成一个unsigned long型的数，所以按照加法运算可以得0x100001

第三个就是把p强制转换成一个指向int的指针，所以（p）+1*sizeof（unsigned int）=0x100004



##### 3.

##### ![Snipaste_2020-11-02_19-03-48](C:\Users\23908\Desktop\Snipaste_2020-11-02_19-03-48.png)

输出：

![Snipaste_2020-11-02_19-05-57](C:\Users\23908\Desktop\Snipaste_2020-11-02_19-05-57.png)

分析：

没懂....求教！

