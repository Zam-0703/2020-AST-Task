# 学习笔记#1

#### 1.代码到.exe可执行文件

原来刚学C语言的时候每次文件夹中都会生成可执行文件，但是没有太关注原理，最多也就知道日常报错的编译部分。经查阅资料，我了解到一个C语言程序代码到可执行文件的前世今生是：源代码→编译→目标代码→链接→可执行代码。

##### 编译

将源代码文件(.c)通过编译器生成目标代码文件(.obj)，源代码即为程序员手打内容，包含头文件与主函数等部分。目标代码文件则储存经编译器转换后的机器语言代码。

##### 链接

通过链接器将库代码(库其实也就是一组提前写好的目标文件的打包)与启动代码等与目标代码文件(.obj)链接，生成可执行代码。

#### 2.ASCII码与char类型

ASCII 全称为 ( American Standard Code for Information Interchange)，简单的说，就是用 7 位二进制 ( 即 十进制表示为 0 到 127 ) 去编码我们生活中常见的数字，大小写字母，标点符号以及一些特殊的控制字符。这样规定的原因是计算机不认字符只认数字。当我们想使用某字符，可以存储其对应的ASCII码值，再用printf格式化输出。所以当我们声明变量初始化时，如char a = 'a'，实际上计算机储存的仍是97/0x61。

#### 3.进制转换

从别的进制转换到十进制一直很熟练233

十进制到其他进制就是一直取余数

网上查阅资料后了解了二、八、十六进制的相互转换和小数部分的转换方法

#### 4.C中各进制数字的写法

前缀：

二进制: 0b  

八进制: 0

十六进制: 0x

转换说明：

八进制：%o

十六进制：%x

#### 5.计算机中存储数据的方式（原码、补码、反码）

数据在计算机中都是以八位二进制码存储的，其中首位是符号位，1表示负数，0表示正数
只讨论数的储存方式，原码即为原十进制数对应的二进制数（多了一个符号位），原码间的相加没有问题，但是由于符号位相减出了问题，所以出现了反码，将相减转换成相加。而此时负数的相加出了问题，最后引入了补码，利用同余的思想把相减转换成相加。

#### 6.运行结果

15
17
017
f
0xf
12

1.int x = 017,表示将x初始化为八进制的17；

2.第一行，转换说明为%d，应输出十进制数，换算得15；

3.第二行，转换说明为%o，应输出八进制数17；

4.第三行，转换说明为%#o，应输出带前缀0的八进制数，即017；

5.第四行，转换说明为%x，应输出十六进制数，对应十进制中15，即f；

6.第五行，转换说明为%#x，应输出带前缀0x的十六进制数，即0xf；

7.第六行，仅有一个转换说明，取第一个数即a的值。



## 思考题

1.#define无数据类型区别而const有；#define是直接替换，不分配内存，const需要进行内存分配；#define不能作为实参传递给函数，const常量可以。

2.C中无字符串string，用char类型的数组加以替换，而当定义数组时系统已经将数组首元素的地址赋给数组名，故不用再加&，若再加表示的是数组首元素地址的地址。

3.①int a = 8;printf("%p",a); 相当于以十六进制打印a；

   ②int a = 8;printf("%p",&a); 相当于打印a的地址；

   ③int a=8;int *p;p=&a;printf("%p",p);相当于打印a的地址；

   ④int a=8;int \*p;p=&a;printf("%p\n",*p); 相当于以十六进制打印a；

   ⑤int a=8;int *p;p=&a;printf("%p\n",&p); 相当于打印指针p的存储地址。

