为什么C语⾔数组中，构成数组的各个元素必须具有相同的数据类型。？

* 不同的数据类型所占的空间不同，在指针指向数组时，如果数组内部的元素不同，在p++时就有可能跳过一个。  
  

2. 思考题

   * int型和long int 型 地址编号每次加4
   * float型 地址编号每次加4
   * char型 地址编号每次加1（这也是在malloc申请内存时直接strlen+1的原因吧）
   * double型和long long int型 地址编号每次加8


   3.关于强制类型转换。(笔记)

   ```
   	char *p;
   	int a[10]={1,2,3,4,5};
   	p = (char*)a;
   	for(;p<(char*)a+25;p++)
   	printf("%d ",*p);
   ```

   输出结果： 1 0 0 0 2 0 0 0 3 ……  
   原因：强制类型转换并未转换a数组的类型，数组中每个数间隔为4，而指针的步长为1。

   4.(笔记)

   ```
       char *a[10];
   	printf("%d",sizeof(*a));
   	printf("%d",sizeof(a));
   	return 0;
   	//输出的结果为 8(指针步长) 80(数组长度*指针步长)  
   ```

------

  5.（提高题1）

   * cpp\[-1][-1]=\*(\*(cpp-1)-1)  ；

   * *--*++cpp + 3 在找到ENTER后向前移三位然后输出EW；

     

------

   6.（提高题3）

![网上查到的图片](C:\Users\ASUS'\Desktop\task 2\QQ截图20201028070435.png)

* *ptr1 = (int *)(&a + 1) ，&a类型为int(\*)[4]，所以&a+1 = a + sizeof(a) ，\*ptr是 int类型指针 在输出时\*ptr[-1]就相当于数组向前移了以为所以输出a[4]。
* int *ptr2 = (int *)((int)a + 1);是将数组a转化为整型变量在强制+1字节.如果系统是小端序的,输出的为02000000,如果是大端序的,则输出的为00000002.小端序是低地址对应最低位,大端序是高地址对应最低位.



7.(提高题2)

* p是一个指针,且该指针的地址为100000(16进制).该指针指向的结构体对应的字节数为20.
* p+0x1=p+siziof(struct Test),因为是16进制所以输出00100014
* (unsigned long)p + 0x1,则是将p转化为无符号型整数后在+1,所以输出为00100001
* (unsigned int*)p + 0x1=p+sizeof(unsigned int\*) 所以输出00100004.

